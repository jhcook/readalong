---
alwaysApply: true
---

# API Contract Validation & Backward Compatibility

These requirements ensure API stability and prevent breaking changes to documented contracts.
Any violation may result in VERDICT: BLOCK during review.

---

## 1. OpenAPI Specification as Source of Truth

### Documentation Requirements
- The canonical API contract is defined in `docs/openapi.yaml` and `docs/openapi.json`.
- All REST API endpoints MUST be documented in the OpenAPI spec.
- The OpenAPI spec MUST be kept in sync with implementation.
- Any change to API endpoints, request/response schemas, or parameters MUST update the OpenAPI spec.

### Validation Process
- Before implementing API changes, consult `docs/openapi.yaml` to understand current contract.
- After implementing API changes, regenerate OpenAPI spec using `python scripts/generate_openapi.py`.
- Compare old vs new OpenAPI spec to identify breaking changes.

---

## 2. Breaking Changes Detection

### What Constitutes a Breaking Change

**BREAKING (BLOCK):**
- Removing an endpoint
- Removing a request parameter (required or optional)
- Removing a response field that clients may depend on
- Changing a field type (e.g., string → integer, object → array)
- Making an optional parameter required
- Changing HTTP method (GET → POST, etc.)
- Changing endpoint path/URL
- Changing authentication requirements
- Narrowing accepted values (e.g., enum with fewer options)
- Changing error response structure
- Removing support for a content-type (e.g., removing JSON support)

**NON-BREAKING (APPROVE):**
- Adding a new endpoint
- Adding an optional request parameter
- Adding a new response field
- Making a required parameter optional
- Expanding accepted values (e.g., enum with more options)
- Adding support for a new content-type
- Improving error messages (without changing structure)
- Adding new HTTP headers (optional)

### Detection Method
1. **Manual Review**: Compare staged changes in `src/servers/rest_server.py` against `docs/openapi.yaml`
2. **Automated Check**: Run `python scripts/generate_openapi.py` and diff against committed version
3. **Schema Comparison**: Check for removed/modified fields in Pydantic models in `src/core/models.py`

---

## 3. Enforcement Rules

### @Architect Responsibilities
- Review all API changes for architectural impact
- Identify breaking changes by comparing against OpenAPI spec
- BLOCK if breaking changes are introduced without:
  - Explicit justification
  - Migration plan for existing clients
  - Versioning strategy (if applicable)
- Ensure new endpoints follow existing patterns and conventions

### @Security Responsibilities
- Verify that API changes don't introduce security regressions
- Check that authentication/authorization requirements are maintained or strengthened
- Ensure backward-compatible changes don't accidentally expose sensitive data

### @QA Responsibilities
- Verify OpenAPI spec is updated for all API changes
- Run `python scripts/generate_openapi.py` and check for drift
- Ensure integration tests cover both old and new behavior (if backward-compatible changes)
- BLOCK if:
  - OpenAPI spec is out of sync with implementation
  - Breaking changes lack test coverage for migration path

### @Docs Responsibilities
- Document breaking changes in CHANGELOG or migration guide
- Update API documentation to reflect changes
- Ensure deprecation notices are added for endpoints being removed
- Document the rationale for breaking changes

### @Compliance Responsibilities
- Ensure compliance with relevant regulations (e.g., GDPR, SOC2)
- Verify lawful basis for data processing
- Ensure retention and deletion policies are followed

### @Observability Responsibilities
- Ensure logging is appropriate for API changes
- Verify metrics are collected for API performance
- Ensure tracing is enabled for API requests

---

## 4. Preflight Checklist for API Changes

When reviewing changes to `src/servers/rest_server.py`, `src/core/models.py`, or API-related code:

- [ ] Load current OpenAPI spec from `docs/openapi.yaml`
- [ ] Identify all modified endpoints, request models, and response models
- [ ] For each change, classify as BREAKING or NON-BREAKING
- [ ] If BREAKING:
  - [ ] Verify explicit justification is provided
  - [ ] Check for versioning or migration strategy
  - [ ] Ensure CHANGELOG/migration docs are updated
  - [ ] Default to BLOCK unless exceptional circumstances
- [ ] If NON-BREAKING:
  - [ ] Verify OpenAPI spec is updated
  - [ ] Ensure new fields/endpoints are tested
  - [ ] Check that existing tests still pass
- [ ] Regenerate OpenAPI spec and verify no unexpected changes

---

## 5. Implementation Workflow for API Changes

### Phase 1: Design Review (@Architect)
1. Review proposed API changes against current OpenAPI spec
2. Identify breaking vs non-breaking changes
3. If breaking:
   - Require explicit justification
   - Require migration plan
   - Consider API versioning (e.g., `/api/v2/...`)
4. If non-breaking:
   - Ensure follows existing patterns
   - Verify backward compatibility

### Phase 2: Implementation (@BackendEngineer)
1. Make code changes to `src/servers/rest_server.py` and models
2. Update Pydantic models in `src/core/models.py`
3. Ensure backward compatibility for non-breaking changes
4. Add deprecation warnings for endpoints being phased out

### Phase 3: Validation (@QA)
1. Regenerate OpenAPI spec: `python scripts/generate_openapi.py`
2. Compare new spec with committed version
3. Verify all changes are intentional
4. Run integration tests against new API
5. For backward-compatible changes, test that old clients still work

### Phase 4: Documentation (@Docs)
1. Update `docs/openapi.yaml` with new spec
2. Document breaking changes in CHANGELOG
3. Update API usage examples if needed
4. Add migration guide for breaking changes

---

## 6. Exceptions and Overrides

Breaking changes may be approved ONLY if:
- The API is explicitly marked as unstable/beta
- The breaking change fixes a critical security vulnerability
- The change is required for legal compliance (GDPR, etc.)
- A clear migration path and timeline is provided
- All known clients have been notified and updated

Even with exceptions, @Architect MUST explicitly document the justification.

---

## 7. Tools and Automation

### Required Scripts
- `scripts/generate_openapi.py`: Regenerate OpenAPI spec from FastAPI app
- Future: `scripts/validate_api_compatibility.py`: Automated breaking change detection

### Recommended Workflow
```bash
# Before making API changes
cp docs/openapi.yaml docs/openapi.yaml.backup

# After making changes
python scripts/generate_openapi.py

# Compare for breaking changes
diff docs/openapi.yaml.backup docs/openapi.yaml

# If non-breaking, commit new spec
git add docs/openapi.yaml docs/openapi.json
```

---

## 8. Enforcement

- If a breaking change is detected during preflight:
  - @Architect MUST return `VERDICT: BLOCK`
  - @QA MUST return `VERDICT: BLOCK` if OpenAPI spec is not updated
- If OpenAPI spec is out of sync with implementation:
  - @QA MUST return `VERDICT: BLOCK`
- Uncertainty about whether a change is breaking defaults to BLOCK until clarified.
- All agents must treat API contract stability as a first-class, non-negotiable constraint.
